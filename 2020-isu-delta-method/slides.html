<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>The Delta Method and msm R Rackage</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="author" content="Iowa State University, Ecology 607" />
    <meta name="author" content="November 16, 2020" />
    <meta name="author" content="Katherine Goode (kgoode@iastate.edu)" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# The Delta Method and msm R Rackage
### <br>
### Iowa State University, Ecology 607
### November 16, 2020
### Katherine Goode (kgoode@iastate.edu)

---






# Background: AES Stats Consulting

- Offer help with data analyses for ISU researchers (includes graduate students, post docs, faculty, and staff)

- Consulting website: [https://www.stat.iastate.edu/statistical-consulting](https://www.stat.iastate.edu/statistical-consulting)

&lt;img src="figures/aes.png" width="90%" style="display: block; margin: auto;" /&gt;

---

# Overview

&lt;br&gt;

1. What is the delta method?  

2. Mathematical details  

3. `msm` R package  

4. Using `purrr` with `msm`

---

class: inverse, center, middle

# What is the delta method?

---

# Computing a confidence interval

Suppose you take measurements of the length of 30 frogs and want to compute:

- mean length  

- standard deviation of lengths  

- confidence interval for a mean

What do you need to compute a confidence interval for a mean? 

&lt;br&gt;

&lt;img src="figures/frog.jpeg" width="45%" style="display: block; margin: auto;" /&gt;

---

# Standard error

Confidence interval for a sample mean:
 
&lt;br&gt;

`$$\bar{y} \pm z \cdot \mbox{SE}\left[\bar{y}\right]$$`

&lt;br&gt;

where `\(\bar{y}\)` is the sample mean, `\(z\)` is a normal quantile, and 

&lt;br&gt;

`$$\mbox{SE}\left[\bar{y}\right] = \mbox{sd}\left[\bar{y}\right] = \sqrt{Var\left[\bar{y}\right]} = \frac{s}{\sqrt{n}}$$`

&lt;br&gt;

where `\(s\)` is the sample standard deviation and `\(n\)` is the sample size.

&lt;br&gt;

### Standard error: estimate of variability associated with a statistic

---

# Computing standard errors

Some standard errors can be derived using nice properties and have commonly known "nice" formulas (like a sample mean)

&lt;br&gt;

$$
`\begin{array}
\mbox{SE}\left[\bar{y}\right] &amp; = &amp; \sqrt{Var\left[\frac{1}{n} \sum_{i=1}^n y_i \right]} \\
&amp; = &amp; \sqrt{\left(\frac{1}{n}\right)^2\left(\sum_{i=1}^n Var\left[y_i\right]\right)}\\
&amp; = &amp; \sqrt{\frac{1}{n^2}\left(n Var\left[y_i \right]\right)}\\
&amp; = &amp; \sqrt{\frac{1}{n}Var\left[y_i\right]}\\
&amp; = &amp; \frac{\sqrt{Var\left[y_i\right]}}{\sqrt{n}}\\
&amp; = &amp; \frac{s}{\sqrt{n}}
\end{array}`
$$

&lt;br&gt;

Others do not...

---

# Estimating tricky standard errors 

### Delta method: general approach to estimating standard errors

If

- you have a parameter estimate you want to compute a standard error for

- but it doesn't have a commonly used formula

&lt;br&gt;

and

- your parameter estimate is a function of other parameters that do have computed standard errors 

- some other assumptions are met (to be discussed)

&lt;br&gt;

then

- *delta method* can be used to compute the standard error

---

# Mark Recapture Example

Suppose you have data on mule deer survival and calculate several quantities: 

&lt;br&gt;

**(1) Logistic regression equation in MARK for quarterly survival:**

&lt;br&gt;

`$$\log\left(\frac{S_i}{1-S_i}\right)=\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot \mbox{age}_i^2$$` 

for `\(i=1,...,n\)` where `\(S_i\)` represents the quarterly survival at `\(\mbox{age}_i\)`

&lt;br&gt;

**(2) Quarterly survival estimates for specific ages:**

&lt;br&gt;

`$$S_i=\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}.$$`

---

&lt;br&gt;

**(3) Annual survival for a specific age:** 

`$$(S_i)^4$$`

&lt;br&gt;

Now suppose that you are interested in obtaining confidence intervals for the `\(\beta\)`'s, `\(S_i\)` and `\((S_i)^4\)`. Which have nicely derived standard error formulas? 
&lt;br&gt;
&lt;br&gt;

- `\(\beta\)`'s

&lt;br&gt;

- `\(S_i\)`

&lt;br&gt;

- `\((S_i)^4\)`

---

&lt;br&gt;

**(3) Annual survival for a specific age:** 

`$$(S_i)^4$$`

&lt;br&gt;

Out of the quantities in these formulas, which have nicely derived standard error formulas? 

&lt;br&gt;

- `\(\beta\)`'s - Yes!

&lt;br&gt;

- `\(S_i\)` - Yes!

&lt;br&gt;

- `\((S_i)^4\)` - No, will need to derive the standard error using delta method

---

# Summary

&lt;br&gt;

- Standard errors estimate variability associated with a statistic

&lt;br&gt;

- Standard errors are often used to compute confidence intervals

&lt;br&gt;

- **When you need to obtain a standard error for a statistic that doesn't have a nice formula...**

  - **Delta method can be helpful!**
  
  - **(In certain situations)**

---

class: inverse, center, middle

# Mathematical Details

---

# Definitions

| Value | Definition | Example |
| :---: | :--------: | :-----: |
| `\(\boldsymbol{\theta}=(\theta_1,...,\theta_p)\)` |  parameter vector with mean `\(\boldsymbol{\theta}\)` and covariance matrix `\(c_n^2\boldsymbol{\Sigma}\)` | `\(\boldsymbol{\beta}=\left(\beta_0, \beta_1, \beta_2\right)\)` |
| `\(\hat{\boldsymbol{\theta}}_n\)` | a sequence of asymptotically normal estimators of `\(\boldsymbol{\theta}\)` | `\(\hat{\boldsymbol{\beta}}_n=\left(\hat{\beta}_0, \hat{\beta}_1, \hat{\beta}_2\right)\)` |
| `\(g(\boldsymbol{\theta})\)` | a real-valued function of `\(\boldsymbol{\theta}\)` that is continuously differentiable in a neighborhood of `\(\boldsymbol{\theta}\)` | `\(S^4=g\left(\boldsymbol{\beta}\right) =\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\)` |
| `\(g\left(\hat{\boldsymbol{\theta}}\right)\)` | vector of estimates of `\(g(\boldsymbol{\theta})\)` | `\(\hat{S^4} = g\left(\hat{\boldsymbol{\beta}}_n\right)=\left(g\left(\hat{\beta}_0\right), g\left(\hat{\beta}_1\right), g\left(\hat{\beta}_2\right)\right)\)`|

---

# The Delta Method

When the data are IID:

`$$g\left(\hat{\boldsymbol{\theta}}\right) \sim N\left(g(\boldsymbol{\theta}), \ \textbf{d}Cov\left(\hat{\boldsymbol{\theta}}\right)\textbf{d}'\right)$$`
where `\(\textbf{d}\)` vector of length `\(p\)` with a `\(j\)`th element of `$$\frac{\partial g(\boldsymbol{\theta})}{\partial \theta_j}$$`

Note that `\(Cov\left(\hat{\boldsymbol{\theta}}\right)\)` is estimated by the negative inverse Hessian matrix

&lt;br&gt;

Thus, the standard error of `\(g\left(\hat{\boldsymbol{\theta}}\right)\)` can be computed as

&lt;br&gt;

`$$SE\left(g\left(\hat{\boldsymbol{\theta}}\right)\right)=\sqrt{Cov\left(g\left(\hat{\boldsymbol{\theta}}\right)\right)}=\sqrt{\textbf{d}Cov\left(\hat{\boldsymbol{\theta}}\right)\textbf{d}'}.$$`

That is...You can use the above formula to compute the standard error for `\(g(\hat{\boldsymbol{\theta}})\)`!

---

`$$\left(\frac{\partial g(\boldsymbol{\beta})}{\partial \beta_0}, \frac{\partial g(\boldsymbol{\beta})}{\partial \beta_1}, \frac{\partial g(\boldsymbol{\beta})}{\partial \beta_2}\right)$$`

---

# Applying the Delta Method to Derive the Standard Error

In our problem, `\(\hat{\boldsymbol{\beta}}_n=\left(\hat{\beta}_0, \hat{\beta}_1, \hat{\beta}_2\right)\)` is our estimator of `\(\boldsymbol{\beta}=\left(\beta_0, \beta_1, \beta_2\right)\)`. Our real-valued function `\(g(\cdot)\)` is

`$$g\left(\boldsymbol{\beta}\right)=\left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4=S^4.$$`

Keep in mind that `\(S\)` is a function of age, so that when we compute the estimated variance of `\(g\left(\boldsymbol{\beta}\right)\)`, it will be for a specified age.

We need to use `\(g\left(\boldsymbol{\beta}\right)\)` to obtain the elements of `\(\textbf{d}\)` by taking the partial derivatives of `\(g\left(\boldsymbol{\beta}\right)\)` in terms of `\(\beta_0, \beta_1\)`, and `\(\beta_2\)`. These are listed below with details of the derivation included for the partial derivative of `\(g(\boldsymbol{\beta})\)` in terms of `\(\beta_0\)`. The others were computed similarly.

---

# Derivatives 

`$$\begin{eqnarray*}
\frac{\partial g(\boldsymbol{\beta})}{\partial \beta_0}
&amp; = &amp; \frac{\partial}{\partial \beta_0} \left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\\
\\
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^3\times\\
&amp; &amp; \ \ \ \ \ \frac{\partial}{\partial\beta_0}\left(\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\left(1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\right)^{-1}\right)\\
\\
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^3\times\\
&amp; &amp; \ \ \ \ \ \left(\left(\frac{\partial}{\partial\beta_0}\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\right)\left(1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\right)^{-1}+\right).\\
&amp; &amp; \ \ \ \ \ \ \ \ \ \ \left.\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\left(\frac{\partial}{\partial\beta_0}\left(1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\right)^{-1}\right)\right)\\
\\
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^3\times\\
&amp; &amp; \ \ \ \ \ \left(\left(\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)(1)\right)\left(1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\right)^{-1}+\right.\\
&amp; &amp; \ \ \ \ \ \ \ \ \ \ \left.\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\left(-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)(1)}{\left(1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)\right)^{2}}\right)\right)
\end{eqnarray*}`
`\begin{eqnarray*}
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^3\times\\
&amp; &amp; \ \ \ \ \ \left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}-\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^{2}\right)\\
\\
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)\\
\\
\\
\frac{\partial g(\boldsymbol{\beta})}{\partial \beta_1}
&amp; = &amp; \frac{\partial}{\partial \beta_1} \left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\\
\\
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)(\mbox{age})\\
\\
\\
\frac{\partial g(\boldsymbol{\beta})}{\partial \beta_2}
&amp; = &amp; \frac{\partial}{\partial \beta_2} \left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\\
\\
&amp; = &amp; 4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)(\mbox{age}^2)
\end{eqnarray*}$$`

Thus,
  $$\textbf{d}'=\left[\begin{array}{l} 
  4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
  \right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
  \right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^
  2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
  \right)\\
  4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
  \right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
  \right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
  \right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
  \right)(\mbox{age})\\
  4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
  \right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
  \right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
  \right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
  \right)(\mbox{age}^2)
  \end{array}\right].$$`
  
With this, we can compute the standard error of `\(\hat{S}^4=g\left(\hat{\boldsymbol{\beta}}\right)\)` for a given age as

`$$SE\left[\hat{S}^4\right]=\sqrt{Var\left[g\left(\hat{\boldsymbol{\beta}}\right)\right]}=\sqrt{\textbf{d}Cov\left[\hat{\boldsymbol{\beta}}\right]\textbf{d}'}$$`

where the values of `\(\beta_0\)`, `\(\beta_1\)`, and `\(\beta_2\)` in `\(\textbf{d}\)` will be replaced by `\(\hat{\beta}_0\)`, `\(\hat{\beta}_1\)`, and `\(\hat{\beta}_2\)`.

---

# Function for Computing the Standard Error in R


```r
library(dplyr)
library(ggplot2)
library(readr)
```

I wrote the function `compute_annual_se` to implement the delta method computations to compute the standard error for annual survival. The function also returns the estimate of the annual survival and a 95% confidence interval for annual survival. The inputs and outputs of the function are as follows.

Inputs:

* `age`: age at which to compute the annual survival estimate and standard error
* `betas`: estimated logistic regression coefficients (should be a vector of length 3)
* `vcov`: estimated variance covariance matrix of the logistic regression coefficients (should be a 3x3 matrix)

Outputs:

* data frame with the variables of 
    + `Age`: age that was specified for the computations
    + `Annual_Survival`: estimated annual survival for the specified `Age`
    + `Annual_SE`: standard error for the annual survival (estimated using the delta method)
    + `Annual_Lower`: lower bound of the 95% confidence interval for annual survival
    + `Annual_Upper`: upper bound of the 95% confidence interval for annual survival

The code for the function `compute_annual_se` is included below.

\vspace{0.5cm}


```r
# Function for computing the standard error of the estimate of annual survival
compute_annual_se &lt;- function(age, betas, vcov){
  
  # Separate the betas
  b0 &lt;- betas[1]
  b1 &lt;- betas[2]
  b2 &lt;- betas[3]
  
  # Compute the logit of quarterly survival for the given age
  logit_s &lt;- b0 + (b1 * age) + (b2 * (age^2))
  
  # Compute the quarterly survival
  s &lt;- exp(logit_s) / (1 + exp(logit_s))
  
  # Create an empty 1x3 matrix to store the elements of d in
  d &lt;- matrix(NA, nrow = 1, ncol = 3)
  
  # Compute the elements of d (partial derivatives of g(beta))
  d[1] &lt;- 4 * (s^4) * (1 - s)
  d[2] &lt;- 4 * age * (s^4) * (1 - s)
  d[3] &lt;- 4 * (age^2) * (s^4) * (1 - s)
  
  # Compute the standard error of annual survival (using the delta method)
  se &lt;- sqrt(d %*% vcov %*% t(d))
  
  # Compute the estimate of annual survival
  annual &lt;- s^4
  
  # Compute the lower and upper bounds of the 95% CI for annual survival
  lower &lt;- annual - (1.96 * se)
  upper &lt;- annual + (1.96 * se)
  
  # Return the age, annual survial estimate, annual survival standard error, and 
  # the lower and upper bounds of the 95% CI for the annual survival
  return(data.frame(Age = age,
                    Annual_Survival = annual, 
                    Annual_SE = se, 
                    Annual_Lower = lower, 
                    Annual_Upper = upper))
  
}
```

# Applying the Standard Error Function

I transferred the values from the `AgeEquations.xlsx` spreadsheet that Bob provided to me to separate .csv files. These files are described and read in below.

The file `age_and_survival.csv` contains a data frame with the logit of quarterly survival, quarterly survival, standard error of quarterly survival, and annual survival computed by Bob based on the logistic regression model fit in MARK. This dataset is read in with the following code, and the first six rows of the dataset are included in the table below.

\vspace{0.5cm}


```r
# Read in the survival data put together by Bob
survival_data &lt;- read.csv("../../../../Desktop/consulting/clients/Klaver_Bob/data/age_and_survival.csv") %&gt;%
  rename(Quarterly = S..Qarterly.,
         Annual = S.Annual.)
```

\vspace{0.25cm}


| Age|    Logit| Quarterly|        SE|    Annual|
|---:|--------:|---------:|---------:|---------:|
| 1.0| 2.701260| 0.9371009| 0.0219128| 0.7711618|
| 1.1| 2.725346| 0.9385058| 0.0205651| 0.7757964|
| 1.2| 2.748443| 0.9398254| 0.0193408| 0.7801689|
| 1.3| 2.770552| 0.9410636| 0.0182339| 0.7842886|
| 1.4| 2.791672| 0.9422242| 0.0172384| 0.7881646|
| 1.5| 2.811804| 0.9433104| 0.0163487| 0.7918054|

The file `betas.csv` contains the estimates of logistic regression coefficients, and the file `vcov.csv` contains the estimated covariance matrix of coefficients. These files are read in with the following code.

\vspace{0.5cm}


```r
# Read in the beta estimates and the variance covariance matrix of the betas
betas &lt;- read_csv("../../../../Desktop/consulting/clients/Klaver_Bob/data/betas.csv", col_names = FALSE) %&gt;% as.matrix()
vcov &lt;- read_csv("../../../../Desktop/consulting/clients/Klaver_Bob/data/vcov.csv", col_names = FALSE) %&gt;% as.matrix()
```

\vspace{0.25cm}

The estimates of the coefficients are `\(\boldsymbol{\hat{\beta}}=\left(\right.\)` 2.41, 0.34, -0.05 `\(\left.\right)\)`, and the estimated variance covariance matrix, `\(Var\left[\hat{\beta}\right]\)` is as follows.


|       |       |       |
|------:|------:|------:|
|  0.335| -0.145|  0.013|
| -0.145|  0.083| -0.008|
|  0.013| -0.008|  0.001|

The following code applies the `compute_annual_se` function to all of the ages included in the `survival_data`. This code makes use of the `map_df` function from the `purrr` package in R, which is similar to the apply family in base R. The first six rows of the resulting dataset are shown in the table below.

\vspace{0.5cm}


```r
# Apply the compute_annual_se function to all of the ages in the survival data
survival_data_annual &lt;- purrr::map_df(survival_data$Age, 
                                      compute_annual_se, 
                                      betas = betas, 
                                      vcov = vcov)
```

\vspace{0.25cm}


| Age| Annual_Survival| Annual_SE| Annual_Lower| Annual_Upper|
|---:|---------------:|---------:|------------:|------------:|
| 1.0|       0.7711618| 0.0721301|    0.6297867|    0.9125368|
| 1.1|       0.7757964| 0.0679987|    0.6425190|    0.9090739|
| 1.2|       0.7801689| 0.0642209|    0.6542960|    0.9060418|
| 1.3|       0.7842886| 0.0607849|    0.6651502|    0.9034271|
| 1.4|       0.7881646| 0.0576792|    0.6751134|    0.9012159|
| 1.5|       0.7918054| 0.0548918|    0.6842175|    0.8993934|

The code below joins Bob's survival dataset with the dataset obtained using the `compute_annual_se` function. It also renames some of the variables in Bob's dataset to better distinguish the variables, and it computes 95% confidence intervals for `\(S^4\)` by first computing 95% confidence intervals for `\(S\)` and then raising the lower and upper bounds to the fourth power. The first six rows of the resulting dataset are shown in the two tables below.

\vspace{0.5cm}


```r
# Join Bob's survival data with the values computed by the compute_annual_se function
# Also rename some variables and add the "easy" CI bounds
survival_data_joined &lt;- full_join(survival_data, survival_data_annual, by = "Age") %&gt;%
  rename(Quarterly_Survival = Quarterly,
         Quarterly_SE = SE, 
         Annual_Survival_Bob = Annual) %&gt;%
  mutate(Annual_Lower_Easy = (Quarterly_Survival - (1.96 * Quarterly_SE))^4,
         Annual_Upper_Easy = (Quarterly_Survival + (1.96 * Quarterly_SE))^4)
```

\vspace{0.25cm}


| Age|    Logit| Quarterly_Survival| Quarterly_SE| Annual_Survival_Bob| Annual_Survival|
|---:|--------:|------------------:|------------:|-------------------:|---------------:|
| 1.0| 2.701260|          0.9371009|    0.0219128|           0.7711618|       0.7711618|
| 1.1| 2.725346|          0.9385058|    0.0205651|           0.7757964|       0.7757964|
| 1.2| 2.748443|          0.9398254|    0.0193408|           0.7801689|       0.7801689|
| 1.3| 2.770552|          0.9410636|    0.0182339|           0.7842886|       0.7842886|
| 1.4| 2.791672|          0.9422242|    0.0172384|           0.7881646|       0.7881646|
| 1.5| 2.811804|          0.9433104|    0.0163487|           0.7918054|       0.7918054|



| Annual_SE| Annual_Lower| Annual_Upper| Annual_Lower_Easy| Annual_Upper_Easy|
|---------:|------------:|------------:|-----------------:|-----------------:|
| 0.0721301|    0.6297867|    0.9125368|         0.6392124|         0.9225564|
| 0.0679987|    0.6425190|    0.9090739|         0.6508619|         0.9179085|
| 0.0642209|    0.6542960|    0.9060418|         0.6617089|         0.9138643|
| 0.0607849|    0.6651502|    0.9034271|         0.6717667|         0.9103873|
| 0.0576792|    0.6751134|    0.9012159|         0.6810502|         0.9074434|
| 0.0548918|    0.6842175|    0.8993934|         0.6895764|         0.9050006|

The plot below shows the estimated annual survival (black solid line) versus age. The blue dashed lines are the 95% confidence interval for annual survival computed using the delta method, and the grey dotted lines are the 95% confidence interval computed the "easy" way by raising the lower and upper bounds of the confidence interval for the quarterly survival to the fourth power.

\vspace{0.5cm}

&lt;img src="slides_files/figure-html/unnamed-chunk-13-1.png" style="display: block; margin: auto;" /&gt;

# Comparing My Function to `msm` R Package Function

While working on this problem, I discovered that the R package `msm` contains the function `deltamethod` that can be used to apply the delta method to obtain a standard error. This function requires a formula representing the function `\(g(\cdot)\)` as the first argument, the estimated coefficients from the logistic regression as the second argument, and the variance-covariance matrix of the coefficients for the third argument. I wrote the function `apply_msm_deltamethod` to apply the function `deltamethod` to a specified age. The inputs and output of the function are as follows.

Inputs:

* `age`: age at which to compute the annual survival estimate and standard error
* `betas`: estimated logistic regression coefficients (should be a vector of length 3)
* `vcov`: estimated variance covariance matrix of the logistic regression coefficients (should be a 3x3 matrix)

Outputs:

* data frame with the variables of 
    + `Age`: age that was specified for the computations
    + `msm_SE`: SE of annual survival that was computed using the msm function `deltamethod` for the specified age
    
The code for the function is shown below.

\vspace{0.5cm}


```r
# Function for applying the msm function deltamethod to a specified age
apply_msm_deltamethod &lt;- function(age, betas, vcov){
  
  # Create the form of the formula to put in the deltamethod function
  formula &lt;- sprintf("~ (exp(x1 + (x2 * %f) + (x3 * %f)) / 
                     (1 + exp(x1 + (x2 * %f) + (x3 * %f))))^4", age, age^2, age, age^2)

  # Apply the deltamethod function
  se = msm::deltamethod(as.formula(formula), mean = betas, cov = vcov)
  
  # Return the se in a dataframe
  return(data.frame(Age = age,
                    msm_SE = se))
    
}
```

\vspace{0.25cm}

The code below uses the function `apply_msm_deltamethod` to apply the `msm` function `deltamethod` to all of the ages in the survival data. It then joins the newly computed standard error to the survival data. The first six rows of the resulting data frame are shown in the table below.

\vspace{0.5cm}


```r
# Compute the annual standard errors for all ages using the deltamethod function
mse_values &lt;- purrr::map_df(survival_data_joined$Age, 
                            apply_msm_deltamethod, 
                            betas = betas, 
                            vcov = vcov)
```

\vspace{0.25cm}


| Age|    msm_SE|
|---:|---------:|
| 1.0| 0.0721301|
| 1.1| 0.0679987|
| 1.2| 0.0642209|
| 1.3| 0.0607849|
| 1.4| 0.0576792|
| 1.5| 0.0548918|

The plot below shows the annual standard error that I computed versus the standard error computed by the `msm` package. The solid line is the 1-1 line. All of the points appear to fall on this lines, which indicates that my computations agree with the `msm` package.

\vspace{0.5cm}

&lt;img src="slides_files/figure-html/unnamed-chunk-17-1.png" style="display: block; margin: auto;" /&gt;

---

# Additional Resource

A good reference on the delta method that also describes how to apply the delta method in R can be found on the [IDRE website](https://stats.idre.ucla.edu/r/faq/how-can-i-estimate-the-standard-error-of-transformed-regression-parameters-in-r-using-the-delta-method/).
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
