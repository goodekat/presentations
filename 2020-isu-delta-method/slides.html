<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>The Delta Method and msm R Rackage</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="author" content="Iowa State University, Ecology 607" />
    <meta name="author" content="November 16, 2020" />
    <meta name="author" content="Katherine Goode (kgoode@iastate.edu)" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# The Delta Method and msm R Rackage
### <br>
### Iowa State University, Ecology 607
### November 16, 2020
### Katherine Goode (kgoode@iastate.edu)
### <br><br>Find slides at: goodekat.github.io/presentations.html

---


&lt;style type="text/css"&gt;
.tiny{font-size: 30%}
.small{font-size: 50%}
.medium{font-size: 75%}
&lt;/style&gt;





# Background: AES stats consulting

- Offer help with data analyses for ISU researchers (includes graduate students, post docs, faculty, and staff)

- Consulting website: [https://www.stat.iastate.edu/statistical-consulting](https://www.stat.iastate.edu/statistical-consulting)

&lt;img src="figures/aes.png" width="90%" style="display: block; margin: auto;" /&gt;

---

# Slide structure

&lt;br&gt;

1. What is the delta method?  

2. Mathematical details  

3. Delta method in R by hand

4. Delta method in R via `msm`

---

class: inverse, center, middle

# What is the delta method?

---

## Computing a confidence interval

Suppose you take measurements of the length of 30 frogs and want to compute:

- mean length

- standard deviation of lengths

- confidence interval for a mean

What do you need to compute a confidence interval for a mean?

&lt;br&gt;

&lt;img src="figures/frog.jpeg" width="45%" style="display: block; margin: auto;" /&gt;

---

## Standard error

**Standard error**: estimate of variability associated with a statistic

**Example:**

Confidence interval for a sample mean:

&lt;br&gt;

`$$\bar{y} \pm z \cdot \mbox{SE}\left[\bar{y}\right]$$`

&lt;br&gt;

where `\(\bar{y}\)` is the sample mean, `\(z\)` is a normal quantile, and

&lt;br&gt;

`$$\mbox{SE}\left[\bar{y}\right] = \mbox{sd}\left[\bar{y}\right] = \sqrt{Var\left[\bar{y}\right]} = \frac{s}{\sqrt{n}}$$`

&lt;br&gt;

where `\(s\)` is the sample standard deviation and `\(n\)` is the sample size.

---

## Computing standard errors

Some standard errors are easy to derive/compute (like a sample mean)

&lt;br&gt;

$$
`\begin{array}
\mbox{SE}\left[\bar{y}\right] &amp; = &amp; \sqrt{Var\left[\frac{1}{n} \sum_{i=1}^n y_i \right]} \\
&amp; = &amp; \sqrt{\left(\frac{1}{n}\right)^2\left(\sum_{i=1}^n Var\left[y_i\right]\right)}\\
&amp; = &amp; \sqrt{\frac{1}{n^2}\left(n Var\left[y_i \right]\right)}\\
&amp; = &amp; \sqrt{\frac{1}{n}Var\left[y_i\right]}\\
&amp; = &amp; \frac{\sqrt{Var\left[y_i\right]}}{\sqrt{n}}\\
&amp; = &amp; \frac{s}{\sqrt{n}}
\end{array}`
$$

&lt;br&gt;

Others do not...

---

## Estimating tricky standard errors

&lt;br&gt;

**Delta method**: approach to approximate standard errors of transformed parameters

&lt;br&gt;

If

- want a SE for a parameter estimate

- doesn't have a commonly used formula, is accessible via software, or derived easily

and

- parameter estimate is a function of other parameters with known SEs

- some other assumptions are met (to be discussed)

then

- **delta method** can be used to compute the standard error

---

## Mule deer example

Suppose you have data on mule deer survival and calculate several quantities:

&lt;br&gt;

**(1) Logistic regression equation in MARK for quarterly survival:**

`$$\log\left(\frac{S_i}{1-S_i}\right)=\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot \mbox{age}_i^2$$`

for `\(i=1,...,n\)` where `\(S_i\)` represents the quarterly survival at `\(\mbox{age}_i\)`

&lt;br&gt;

**(2) Quarterly survival estimates for specific ages:**

`$$S_i=\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}.$$`

&lt;br&gt;

**(3) Annual survival for a specific age:** `\(\ \ \ (S_i)^4\)`

---

## Try it out

Suppose that you are interested in obtaining confidence intervals for the `\(\beta\)`'s, `\(S_i\)` and `\((S_i)^4\)`. Which would you need to use the delta method to derive?

&lt;br&gt;
&lt;br&gt;

- `\(\beta\)`'s

&lt;br&gt;

- `\(S_i\)`

&lt;br&gt;

- `\((S_i)^4\)`

---

## Try it out: Solution

Suppose that you are interested in obtaining confidence intervals for the `\(\beta\)`'s, `\(S_i\)` and `\((S_i)^4\)`. Which would you need to use the delta method to derive?

&lt;br&gt;
&lt;br&gt;

- `\(\beta\)`'s - No

&lt;br&gt;

- `\(S_i\)` - Technically can get from MARK but is (probably) derived using the delta method

&lt;br&gt;

- `\((S_i)^4\)` - Will need to derive the standard error using delta method

---

## Summary

&lt;br&gt;

- Standard errors estimate variability associated with a statistic

&lt;br&gt;

- Standard errors are often used to compute confidence intervals

&lt;br&gt;

- **Delta method can be used to approximate standard errors of transformed parameters that are not easy to compute**

---

class: inverse, center, middle

# Mathematical details

---

## Definitions and conditions

| Value | Definition | Conditions |
| :---: | :--------: | :-------: |
| `$$\boldsymbol{\theta}=(\theta_1,...,\theta_p)$$` |  parameter vector | has mean `\(\boldsymbol{\theta}\)` and variance-covariance matrix `\(Cov(\boldsymbol{\theta})\)` |
| `$$\hat{\boldsymbol{\theta}}$$` | sequence of estimators of `\(\boldsymbol{\theta}\)` | asymptotically normal |
| `$$g(\boldsymbol{\theta})$$` | function of `\(\boldsymbol{\theta}\)` | real-valued and continuously differentiable in a neighborhood of `\(\boldsymbol{\theta}\)` |
| `$$g\left(\hat{\boldsymbol{\theta}}\right)$$` | estimate of `\(g(\boldsymbol{\theta})\)` | - |
| `\(\textbf{d}\)` | vector of partial derivatives of length `\(p\)` with a `\(j\)`th element of `$$\frac{\partial g(\boldsymbol{\theta})}{\partial \theta_j}$$` | - |

---

## The Delta Method

**Situation/conditions**

- Parameter estimate `\(g\left(\hat{\boldsymbol{\theta}}\right)\)` a function of parameters `\(\hat{\boldsymbol{\theta}}\)`
- `\(\boldsymbol{\theta}\)` has known variance covariance matrix `\(Cov\left(\hat{\boldsymbol{\theta}}\right)\)`

**Results**

- `\(g\left(\hat{\boldsymbol{\theta}}\right)\)` follows a normal distribution:

`$$g\left(\hat{\boldsymbol{\theta}}\right) \sim N\left(g(\boldsymbol{\theta}), \ \textbf{d}Cov\left(\hat{\boldsymbol{\theta}}\right)\textbf{d}'\right)$$`

- .orange[Standard error of] `\(g\left(\hat{\boldsymbol{\theta}}\right)\)` .orange[can be computed as]

`$$SE\left(g\left(\hat{\boldsymbol{\theta}}\right)\right)=\sqrt{Cov\left(g\left(\hat{\boldsymbol{\theta}}\right)\right)}=\sqrt{\textbf{d}Cov\left(\hat{\boldsymbol{\theta}}\right)\textbf{d}'}.$$` 

- &lt;small&gt; (Note that `\(Cov\left(\hat{\boldsymbol{\theta}}\right)\)` is estimated by the negative inverse Hessian matrix) &lt;/small&gt;

---

## Try it out

Want to compute standard error for `\(S_i^4\)` where 

`$$S_i=\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}$$`

What is the notation in this context?

- `\(\boldsymbol{\theta}=(\theta_1,...,\theta_p)\)`

- `\(\hat{\boldsymbol{\theta}}_n\)`

- `\(g(\boldsymbol{\theta})\)`

- `\(g\left(\hat{\boldsymbol{\theta}}\right)\)`

- `\(\textbf{d}\)`

---

## Try it out: Solution

Want to compute standard error for `\(S_i^4\)` where 

`$$S_i=\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}_i+\beta_2\cdot\mbox{age}_i^2\right)}$$`

What is the notation in this context?

- `\(\boldsymbol{\theta}=(\theta_1,...,\theta_p)=\boldsymbol{\beta}=\left(\beta_0, \beta_1, \beta_2\right)\)`

- `\(\hat{\boldsymbol{\theta}}_n=\hat{\boldsymbol{\beta}}_n=\left(\hat{\beta}_0, \hat{\beta}_1, \hat{\beta}_2\right)\)`

- `\(g(\boldsymbol{\theta})=S^4=g\left(\boldsymbol{\beta}\right) =\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\)`

- `\(g\left(\hat{\boldsymbol{\theta}}\right)=\hat{S^4} = g\left(\hat{\boldsymbol{\beta}}_n\right)=\left(\frac{\exp\left(\hat{\beta}_0+\hat{\beta}_1\cdot\mbox{age}+\hat{\beta}_2\cdot\mbox{age}^2\right)}{1+\exp\left(\hat{\beta}_0+\hat{\beta}_1\cdot\mbox{age}+\hat{\beta}_2\cdot\mbox{age}^2\right)}\right)^4\)`

- `\(\textbf{d}=\left(\frac{\partial g(\boldsymbol{\beta})}{\partial \beta_0}, \frac{\partial g(\boldsymbol{\beta})}{\partial \beta_1}, \frac{\partial g(\boldsymbol{\beta})}{\partial \beta_2}\right)\)`

---

## Computing mule deer standard error

&lt;br&gt;

Now, how to compute the standard error for `\(S_i^4\)`?

&lt;br&gt;

`$$SE\left(g\left(\hat{\boldsymbol{\beta}}\right)\right)=\sqrt{\textbf{d}Cov\left(\hat{\boldsymbol{\beta}}\right)\textbf{d}'}$$` 

&lt;br&gt;

Would need to:

- Derive partial derivatives in `\(\textbf{d}\)` (see next slide)

- Compute partial derivatives using estimated parameters from the logistic regression model

- Extract variance-covariance matrix from logistic regression for `\(Cov\left(\hat{\boldsymbol{\beta}}\right)\)`

- Use formula above to put it all together  for computing `\(SE\left(g\left(\hat{\boldsymbol{\beta}}\right)\right)\)`

---

## Mule deer derivatives

The partial derivatives of `\(g\left(\boldsymbol{\beta}\right)\)` in terms of `\(\beta_0, \beta_1\)`, and `\(\beta_2\)`:

&lt;small&gt;
`$$\begin{array}{ccl}
\textbf{d}' &amp; = &amp; \left[\begin{array}{ccc} \frac{\partial}{\partial\beta_0} \left(S^4\right) &amp; \frac{\partial}{\partial\beta_1} \left(S^4\right) &amp; \frac{\partial}{\partial\beta_2} \left(S^4\right) \end{array}\right]'\\
&amp; = &amp; \left[\begin{array}{l} \frac{\partial}{\partial \beta_0} \left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4 \\ \frac{\partial}{\partial \beta_1} \left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4 \\ 
\frac{\partial}{\partial \beta_2} \left(\frac{\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+
\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4 \end{array} \right]\\
&amp; = &amp; \left[\begin{array}{l}
4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)\\
4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2
\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}
\right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)(\mbox{age})\\
4\left(\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)^4\left(1-\frac{\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}{1+\exp\left(\beta_0+\beta_1\cdot\mbox{age}+\beta_2\cdot\mbox{age}^2\right)}\right)(\mbox{age}^2)
\end{array}\right]\\
&amp; = &amp; \left[\begin{array}{l} 4S^4(1-S) \\ 4S^4(1-S)(\mbox{age}) \\ 4S^4(1-S)(\mbox{age})^2 \end{array}\right]
\end{array}.$$`
&lt;/small&gt;

---

## Summary

- For parameters `\(\hat{\boldsymbol{\theta}}\)` with a known variance covariance matrix `\(Cov\left(\hat{\boldsymbol{\theta}}\right)\)`:

  - Can use the delta method to obtain a standard error for a transformation of the parameters: `\(g\left(\hat{\boldsymbol{\theta}}\right)\)` 
  
- Delta method standard error formula:

`$$SE\left(g\left(\hat{\boldsymbol{\theta}}\right)\right)=\sqrt{\textbf{d}Cov\left(\hat{\boldsymbol{\theta}}\right)\textbf{d}'}$$`

- Involves computing partial derivatives

---

class: inverse, center, middle

# Delta method in R by hand

---

## Mule deer example in R

### MARK model results


```r
# R packages
library(dplyr); library(readr)
```


```r
# Load data frame of quarterly survival, quarterly survival, 
# standard error of quarterly survival, and annual survival 
# computed based on the logistic regression model fit in MARK
survival_data &lt;- read_csv("data/age_and_survival.csv")

# Print the head of the data
head(survival_data)
```

```
## # A tibble: 6 x 5
##     age logit s_quarterly     se s_annual
##   &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;
## 1   1    2.70       0.937 0.0219    0.771
## 2   1.1  2.73       0.939 0.0206    0.776
## 3   1.2  2.75       0.940 0.0193    0.780
## 4   1.3  2.77       0.941 0.0182    0.784
## 5   1.4  2.79       0.942 0.0172    0.788
## 6   1.5  2.81       0.943 0.0163    0.792
```

---

## Mule deer logisitc regression estimates

### Model coefficients


```r
# Load logistic regression coefficient estimates
betas &lt;- read_csv("data/betas.csv", col_names = FALSE) %&gt;% as.matrix()
betas
```

```
##              X1
## [1,]  2.4060341
## [2,]  0.3446497
## [3,] -0.0494241
```

### Variance-covariance matrix


```r
# Load estimated variance covariance matrix of the logistic regression coefficients
vcov &lt;- read_csv("data/vcov.csv", col_names = FALSE) %&gt;% as.matrix()
vcov
```

```
##               X1           X2            X3
## [1,]  0.33546317 -0.145305616  0.0129216170
## [2,] -0.14530562  0.083162139 -0.0082607889
## [3,]  0.01292162 -0.008260789  0.0008725783
```

---

## Hand written R function 

`compute_annual_se`: Function for computing annual survival standard error via the delta method

Inputs:  

- `age`: age at which to compute the annual survival estimate and standard error
- `betas`: estimated logistic regression coefficients (vector of length 3)
- `vcov`: estimated variance covariance matrix of logistic regression coefficients (3x3 matrix)

Output: data frame with the variables of...

- `age`: age that was specified for the computations
- `annual_survival`: estimated annual survival for specified `age`
- `se`: standard error for annual survival (estimated using delta method)
- `lower`: lower bound of 95% confidence interval for annual survival
- `upper`: upper bound of 95% confidence interval for annual survival

---

.tiny[

```r
# Function for computing annual survival standard error
compute_annual_se &lt;- function(age, betas, vcov){

  # Separate the betas
  b0 &lt;- betas[1]; b1 &lt;- betas[2]; b2 &lt;- betas[3]

  # Compute logit of quarterly survival for given age
  logit_s &lt;- b0 + (b1 * age) + (b2 * (age^2))

  # Compute quarterly and annual survival
  s &lt;- exp(logit_s) / (1 + exp(logit_s))
  annual &lt;- s^4
  
  # Create empty 1x3 matrix to store the elements of d
  d &lt;- matrix(NA, nrow = 1, ncol = 3)

  # Compute elements of d (partial derivatives of g(beta))
  d[1] &lt;- 4 * (s^4) * (1 - s)
  d[2] &lt;- 4 * age * (s^4) * (1 - s)
  d[3] &lt;- 4 * (age^2) * (s^4) * (1 - s)

  # Compute standard error of annual survival (using delta method)
* se &lt;- sqrt(d %*% vcov %*% t(d))
  
  # Compute lower and upper bounds of 95% CI for annual survival
* lower &lt;- annual - (1.96 * se); upper &lt;- annual + (1.96 * se)

  # Return age, annual survival estimate, standard error, 95% CI
  return(data.frame(age, annual_survival = annual, se, lower, upper))

}
```
]

---

## Applying the function to one age


```r
# Apply compute_annual_se when age is 1
age1_se &lt;-
  compute_annual_se(
    age = survival_data$age[1],
    betas = betas,
    vcov = vcov
  )

# Print the results (rounded to 2 decimals)
age1_se
```

```
##   age annual_survival         se     lower     upper
## 1   1       0.7711618 0.07213014 0.6297867 0.9125368
```

---

## Applying the function to multiple ages


```r
# Apply compute_annual_se to all of the ages in survival data
# using map_df from purrr to apply .f to all elements of .x
survival_data_annual &lt;- 
  purrr::map_df(
    .x = survival_data$age, 
*   .f = compute_annual_se,
    betas = betas,
    vcov = vcov
  )

# Print part of the results
head(survival_data_annual)
```

```
##   age annual_survival         se     lower     upper
## 1 1.0       0.7711618 0.07213014 0.6297867 0.9125368
## 2 1.1       0.7757964 0.06799871 0.6425190 0.9090739
## 3 1.2       0.7801689 0.06422088 0.6542960 0.9060418
## 4 1.3       0.7842886 0.06078494 0.6651502 0.9034271
## 5 1.4       0.7881646 0.05767921 0.6751134 0.9012159
## 6 1.5       0.7918054 0.05489182 0.6842175 0.8993934
```

---

## Annual surival by age with confidence intervals


```r
# Plot the estimated annual survival and confidence intervals
library(ggplot2)
ggplot(survival_data_annual, aes(x = age, y = annual_survival)) +
  geom_line() +
  geom_line(aes(x = age, y = lower), linetype = "dashed", color = "blue") +
  geom_line(aes(x = age, y = upper), linetype = "dashed", color = "blue") +
  scale_x_continuous(breaks = seq(1, 11, 1)) +
  labs(x = "Age", y = "Annual Surivial") +
  theme_xaringan()
```

&lt;img src="slides_files/figure-html/unnamed-chunk-11-1.png" width="75%" style="display: block; margin: auto;" /&gt;

---

## Summary

- Could code up a function to compute a delta method standard error in R by hand

- Can use the functions of `map` or `map_df` from `purrr` to apply a function easily to multiple inputs 

---

class: inverse, center, middle

# Delta method in R via msm

---

## msm R package

**Package overview**

- **M**ulti-**S**tate **M**arkov models

- From the online [documentation](https://cran.r-project.org/web/packages/msm/index.html)

&gt; R package for continuous-time multi-state modeling of panel data

- From the [vignette](https://cran.r-project.org/web/packages/msm/vignettes/msm-manual.pdf):

&gt; The multi-state Markov model is a useful way of describing a process in which an individual moves through a series of states in continuous time. The msm package for R allows a general multi-state model to be fitted to longitudinal data.

- **Provides an easier way to apply the delta method**:

  - Includes a `deltamethod` function
  
  - Prevents the computation of partial derivatives (Yay! ðŸ˜„)

---

## `deltamethod` function

Inputs:

- `g` = a formula representing the function: `\(g(\cdot)\)` 
  
&gt; The variables must be labeled `x1`, `x2`,... For example:
  
  ```r
  g = ~ 1 / (x1 + x2)
  ```

- `mean	` = vector of estimated parameters: `\(\hat{\boldsymbol{\theta}}\)`

- `cov` = estimated variance-covariance matrix: `\(Cov\left(\hat{\boldsymbol{\theta}}\right)\)`

- `ses`: If TRUE, returns the standard errors of `\(g(\cdot)\)` (default). If FALSE, returns the variance-covariance matrix of `\(g(\cdot)\)`.

---

## Example 1

.pull-left[
Simple linear regression:

`$$\hat{y}=\hat{\beta}_0+\hat{\beta}_1x_1$$`
]

.pull-right[
Compute standard error for 

`$$\frac{1}{\hat{\beta}_0+\hat{\beta}_1}$$`
]


```r
# Simple linear regression
set.seed(1000)
x1 &lt;- 1:100; y &lt;- rnorm(100, 4*x1, 5)
m1 &lt;- lm(y ~ x1)

# Extract the model coefficients and variance-covariance matrix
bhat1 &lt;- coef(m1)
vc1 &lt;- vcov(m1)

# Estimate of (1 / (b0hat + b1hat))
1 / (bhat1[[1]] + bhat1[[2]])
```

```
## [1] 0.4226072
```

```r
# Approximate standard error
msm::deltamethod(g = ~ 1 / (x1 + x2), mean = bhat1, cov = vc1)                     
```

```
## [1] 0.175727
```

---

## Example 2

.pull-left[
Simple linear regression:

`$$\hat{y}=\hat{\beta}_0+\hat{\beta}_1x_1+\hat{\beta}x_2$$`
]

.pull-right[
Compute standard error for 

`$$\frac{1}{\hat{\beta}_0+\hat{\beta}_1}$$`
]


```r
# Simple linear regression
set.seed(1000)
x1 &lt;- 1:100; x2 &lt;- runif(100); y &lt;- rnorm(100, 4*x1, 5)
m2 &lt;- lm(y ~ x1 + x2)

# Extract the model coefficients and variance-covariance matrix
bhat2 &lt;- coef(m2)[1:2]
vc2 &lt;- vcov(m2)[1:2,1:2]

# Estimate of (1 / (b0hat + b1hat))
1 / (bhat2[[1]] + bhat2[[2]])
```

```
## [1] 0.1930787
```

```r
# Approximate standard error
msm::deltamethod(g = ~ 1 / (x1 + x2), mean = bhat2, cov = vc2)
```

```
## [1] 0.04898642
```

---

## Try it out

For the mule deer example, compute the standard error for `\(\hat{S^4}\)` when `\(\mbox{age}=1\)`.

`$$\hat{S^4}=\left(\frac{\exp\left(\hat{\beta}_0+\hat{\beta}_1\cdot\mbox{age}+\hat{\beta}_2\cdot\mbox{age}^2\right)}{1+\exp\left(\hat{\beta}_0+\hat{\beta}_1\cdot\mbox{age}+\hat{\beta}_2\cdot\mbox{age}^2\right)}\right)^4$$`

&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

Bonus: How to compute the standard error for `\(\hat{S^4}\)` for an arbitrary age?

---

## Try it out: Solution

For the mule deer example, compute the standard error for `\(\hat{S^4}\)` when `\(\mbox{age}=1\)`.

`$$\hat{S^4}=\left(\frac{\exp\left(\hat{\beta}_0+\hat{\beta}_1\cdot\mbox{age}+\hat{\beta}_2\cdot\mbox{age}^2\right)}{1+\exp\left(\hat{\beta}_0+\hat{\beta}_1\cdot\mbox{age}+\hat{\beta}_2\cdot\mbox{age}^2\right)}\right)^4$$`

&lt;br&gt;


```r
# Create the form of the formula to put in the deltamethod function
formula = "~ (exp(x1 + x2 + x3)) / (1 + exp(x1 + x2 + x3))^4"

# Apply the deltamethod function
se = msm::deltamethod(as.formula(formula), mean = betas, cov = vcov)
se
```

```
## [1] 0.0002382685
```

&lt;br&gt;

Bonus: How to compute the standard error for `\(\hat{S^4}\)` for an arbitrary age in R?

&gt; See next slide

---

## Arbitrary age

Function for applying the msm function deltamethod to a specified age:


```r
apply_msm_deltamethod &lt;- function(age, betas, vcov){

  # Create the form of the formula to put in the deltamethod function
  formula &lt;- 
    sprintf("~ (exp(x1 + (x2 * %f) + (x3 * %f)) /
            (1 + exp(x1 + (x2 * %f) + (x3 * %f))))^4", 
            age, age^2, age, age^2)

  # Apply the deltamethod function
  se = msm::deltamethod(as.formula(formula), mean = betas, cov = vcov)

  # Return the se in a dataframe
  return(data.frame(age, se))

}
```


```r
apply_msm_deltamethod(1, betas, vcov)
```

```
##   age         se
## 1   1 0.07213014
```

---

## Multiple ages

We could also use `map_df` to apply the function to multiple ages


```r
purrr::map_df(.x = 1:11, .f = apply_msm_deltamethod, betas, vcov)
```

```
##    age         se
## 1    1 0.07213014
## 2    2 0.04527659
## 3    3 0.04126256
## 4    4 0.04523933
## 5    5 0.05009983
## 6    6 0.05449863
## 7    7 0.06257862
## 8    8 0.09162806
## 9    9 0.15634621
## 10  10 0.21683612
## 11  11 0.17733989
```

---

## Summary

- `deltamethod` function in `msm` R package allows application of delta method without computing derivatives

- Need to input a formula that uses `x1`, `x2`,... for the parameters `\(\hat{\boldsymbol{\theta}}\)`

- Only extract the parameter estimates and corresponding variance-covariance matrix cells needed to compute the transformed parameter

&lt;br&gt;
&lt;br&gt;

**Additional resources**

- A good reference on the delta method that also describes how to apply the delta method in R can be found on the [IDRE website](https://stats.idre.ucla.edu/r/faq/how-can-i-estimate-the-standard-error-of-transformed-regression-parameters-in-r-using-the-delta-method/).

- Another delta method function ([`delta.method`](https://www.rdocumentation.org/packages/alr3/versions/1.1.12/topics/delta.method#:~:text=estimated%20regression%20coefficients-,delta.,known%20or%20estimated%20covariance%20matrix)) the [alr3](https://www.rdocumentation.org/packages/alr3/versions/1.1.12) R package
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
